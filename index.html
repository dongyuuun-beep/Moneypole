<div class="filter-section">
    <input type="text" id="searchInput" class="search-input" placeholder="은행명 또는 상품명 검색...">
    <div style="display:flex; justify-content:space-between; font-size:13px; color:#666;">
        <label><input type="checkbox" id="baseOnly"> 우대금리 제외</label>
        <div id="termFilterContainer">
            <select id="termSelect" style="border:none; background:none; font-weight: bold; color: var(--primary);" onchange="renderList()">
                <option value="all">전체 기간</option>
                <option value="6">6개월</option>
                <option value="12" selected>12개월</option>
                <option value="24">24개월</option>
                <option value="36">36개월</option>
            </select>
        </div>
    </div>
</div>

<script>
    // ... (전역 변수 생략) ...

    function renderList() {
        const listArea = document.getElementById('listArea');
        const keyword = document.getElementById('searchInput').value.toLowerCase();
        const isBaseOnly = document.getElementById('baseOnly').checked;
        const termFilter = document.getElementById('termSelect').value; 
        
        // [수정] CMA 또는 파킹통장일 때 기간 필터 숨김 로직 추가
        const termFilterContainer = document.getElementById('termFilterContainer');
        if (currentType === 'cma' || currentType === 'parking') {
            termFilterContainer.style.display = 'none';
        } else {
            termFilterContainer.style.display = 'block';
        }

        listArea.innerHTML = '';
        if (!allData || allData.length === 0) return;

        let filtered = allData.filter(d => d.type === currentType);

        // [수정] 중복 노출 방지를 위해 상품명+은행명 기준으로 최고 금리 상품 하나만 대표로 추출 (정렬 전)
        const uniqueProducts = {};
        filtered.forEach(item => {
            const key = item.bank + item.name;
            if (!uniqueProducts[key] || uniqueProducts[key].max < item.max) {
                uniqueProducts[key] = item;
            }
        });
        filtered = Object.values(uniqueProducts);

        // 검색어 및 기간 필터링 로직 (기존 유지)
        if (termFilter !== 'all' && currentType !== 'cma' && currentType !== 'parking') {
            filtered = filtered.filter(d => {
                if (d.options) return d.options.some(o => String(o.save_trm) === termFilter);
                return String(d.save_trm) === termFilter;
            });
        }
        // ... (검색어 및 정렬 로직 생략) ...

        filtered.forEach(item => {
            const card = document.createElement('div');
            card.className = 'card';
            // ... (카드 렌더링 생략) ...
            card.onclick = () => openDetail(item);
            listArea.appendChild(card);
        });
    }

    function openDetail(item) {
        currentItem = item;
        const detailView = document.getElementById('detailView');
        detailView.style.display = 'block';
        document.body.classList.add('modal-open');
        detailView.scrollTo(0, 0); 

        document.getElementById('detailBank').innerText = item.bank || '';
        document.getElementById('detailName').innerText = item.name || '';
        
        // [수정] 상세 페이지 금리 표시 방식 변경: "기본 + 우대 = 최고"
        updateDetailRateDisplay(item.base, item.max);

        const calcTermSelect = document.getElementById('calcTermSelect');
        calcTermSelect.innerHTML = '';

        if (item.options && item.options.length > 0 && currentType !== 'cma' && currentType !== 'parking') {
            calcTermSelect.style.display = 'block';
            
            // [수정] 중복된 개월 수 제거 (Set 활용) 및 정렬
            const seenTerms = new Set();
            const uniqueOptions = item.options.filter(opt => {
                if (seenTerms.has(opt.save_trm)) return false;
                seenTerms.add(opt.save_trm);
                return true;
            }).sort((a, b) => a.save_trm - b.save_trm);

            uniqueOptions.forEach((opt, idx) => {
                const optionEl = document.createElement('option');
                optionEl.value = JSON.stringify(opt); // [수정] 전체 옵션 데이터를 value에 저장
                optionEl.innerText = `${opt.save_trm}개월 (연 최고 ${opt.intr_rate2.toFixed(2)}%)`;
                if (opt.save_trm === item.save_trm) optionEl.selected = true;
                calcTermSelect.appendChild(optionEl);
            });
        } else {
            calcTermSelect.style.display = 'none';
        }

        document.getElementById('detailCondition').innerText = item.spcl_cnd || "우대 금리 조건 정보가 없습니다.";
        
        // 차트 초기화 등 (기존 유지)
        doCalc();
    }

    // [추가] 금리 표시를 업데이트하는 공통 함수 (기본 + 우대 분리)
    function updateDetailRateDisplay(base, max) {
        const specialRate = (max - base).toFixed(2);
        document.getElementById('detailBaseRate').innerText = `기본 연 ${base.toFixed(2)}% + 우대 최고 ${specialRate}%`;
        document.getElementById('detailRate').innerText = `최고 연 ${max.toFixed(2)}%`;
    }

    function doCalc() {
        const val = parseFloat(document.getElementById('calcInput').value);
        const calcTermSelect = document.getElementById('calcTermSelect');
        
        let months = parseInt(currentItem.save_trm) || 12;
        let applyBaseRate = currentItem.base || 0;
        let applyMaxRate = currentItem.max || 0;

        // [수정] 드롭다운 변경 시 상단 금리 텍스트도 같이 연동되어 업데이트되도록 로직 추가
        if (calcTermSelect.style.display !== 'none' && calcTermSelect.value) {
            const selectedOpt = JSON.parse(calcTermSelect.value);
            months = parseInt(selectedOpt.save_trm);
            applyBaseRate = selectedOpt.intr_rate;
            applyMaxRate = selectedOpt.intr_rate2;
            
            // 상단 텍스트 즉시 갱신
            updateDetailRateDisplay(applyBaseRate, applyMaxRate);
            document.getElementById('detailTermTag').innerText = `${months}개월 기준`;
        }

        // ... (계산 로직 및 결과 출력 생략) ...
    }
</script>
